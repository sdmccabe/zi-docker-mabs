/* * ZITraders.java * * CSS 610	 * George Mason University			 *  * v0 Spring 2005: basic implementation * v1 Summer 2009: cleaned-up and multithreaded * * Rob Axtell * */import java.util.Calendar;import java.util.Random;import java.text.DecimalFormat;import java.util.concurrent.*;public class ZITraders {    final double version = 2.0;    final boolean verboseOutput = false;    static int numberOfBuyers = 1000000; // upper bound     static int numberOfSellers = 1000000;    final double maxBuyerValue = 30.0;    final double maxSellerCost = 30.0;    static int maxNumberOfTrades = 10000000; // upper bound    final boolean threadedTrades = true;    final int numberOfSubpopulations = 1;    // numberOfThreads is resized later, so the declaration     // here is effectively setting the upper bound on the number of threads    static int numberOfThreads = 500;              // 850 seems to be nearly optimal for 10^6 agents total with a 10 millisecond sleep duration    final int sleepDuration = 10;    boolean doNew = true;    DecimalFormat twoDigits = new DecimalFormat("0.00");    AgentPopulation people;    Data Transactions[] = new Data[numberOfThreads];    // dumb idea ahead:     //Data Transactions[] = new Data[500];    private ZITraders() {        try {            people = new AgentPopulation(numberOfBuyers, maxBuyerValue, numberOfSellers, maxSellerCost);            for (int i = 0; i < numberOfThreads; i++) {                Transactions[i] = new Data();            }        } catch (Exception e) {            e.printStackTrace();        }    }    public void DoSingleThreadedTrades() {        DoTrades tradingRun;        switch (numberOfSubpopulations) {            case 1:                tradingRun = new DoTrades(0, maxNumberOfTrades, 1, numberOfBuyers, 1, numberOfSellers);                tradingRun.run();                break;            case 2:                tradingRun = new DoTrades(0, maxNumberOfTrades / 4, 1, numberOfBuyers / 2, numberOfSellers / 2, numberOfSellers);                tradingRun.run();                tradingRun = new DoTrades(0, maxNumberOfTrades / 4, numberOfBuyers / 2, numberOfBuyers, 1, numberOfSellers / 2);                tradingRun.run();                tradingRun = new DoTrades(0, maxNumberOfTrades / 4, 1, numberOfBuyers / 2, 1, numberOfSellers / 2);                tradingRun.run();                tradingRun = new DoTrades(0, maxNumberOfTrades / 4, numberOfBuyers / 2, numberOfBuyers, numberOfSellers / 2, numberOfSellers);                tradingRun.run();                break;            case 3:                tradingRun = new DoTrades(0, maxNumberOfTrades / 3, 1, numberOfBuyers / 3, 2 * numberOfSellers / 3, numberOfSellers);                tradingRun.run();                tradingRun = new DoTrades(0, maxNumberOfTrades / 3, numberOfBuyers / 3, 2 * numberOfBuyers / 3, numberOfSellers / 3, 2 * numberOfSellers / 3);                tradingRun.run();                tradingRun = new DoTrades(0, maxNumberOfTrades / 3, 2 * numberOfBuyers / 3, numberOfBuyers, 1, numberOfSellers / 3);                tradingRun.run();                break;            case 4:                tradingRun = new DoTrades(0, maxNumberOfTrades / 4, 1, numberOfBuyers / 4, 3 * numberOfSellers / 4, numberOfSellers);                tradingRun.run();                tradingRun = new DoTrades(0, maxNumberOfTrades / 4, numberOfBuyers / 4, numberOfBuyers / 2, numberOfSellers / 2, 3 * numberOfSellers / 4);                tradingRun.run();                tradingRun = new DoTrades(0, maxNumberOfTrades / 4, numberOfBuyers / 2, 3 * numberOfBuyers / 4, numberOfSellers / 4, numberOfSellers / 2);                tradingRun.run();                tradingRun = new DoTrades(0, maxNumberOfTrades / 4, 3 * numberOfBuyers / 4, numberOfBuyers, 1, numberOfSellers / 4);                tradingRun.run();                break;        }    }    public void DoMultiThreadedTrades() {        Thread t[] = new Thread[numberOfThreads];        boolean done = false;        int tradesPerThread = maxNumberOfTrades / numberOfThreads;        int buyersPerThread = numberOfBuyers / numberOfThreads;        int sellersPerThread = numberOfSellers / numberOfThreads;        for (int i = 0; i < numberOfThreads; i++) {	    if(!doNew) {		t[i] = new Thread(new DoTrades(i, 					   tradesPerThread, 					   i * buyersPerThread + 1, 					   (i + 1) * buyersPerThread, 					   i * sellersPerThread + 1, 					   (i + 1) * sellersPerThread));	    }else {		t[i] = new Thread(new DoTradesNew(i, 					   tradesPerThread, 					   i * buyersPerThread + 1, 					   (i + 1) * buyersPerThread, 					   i * sellersPerThread + 1, 					   (i + 1) * sellersPerThread));	    }            t[i].start();        }        while (!done) {            done = true;            for (int i = 0; i < numberOfThreads; i++) {                if (t[i].isAlive()) {                    done = false;                }            }            try {                Thread.sleep(sleepDuration);  //  This is here to keep the action on the threads!            } catch (InterruptedException ie) {            }        }    }public class DoTradesNew implements Runnable {        int threadID;        int maxTrades;        int beginBuyers;        int endBuyers;        int beginSellers;        int endSellers;        //Random randomStream;    public DoTradesNew(int threadNumber, int maxExchanges, int startBuyerIndex, int endBuyerIndex, int startSellerIndex, int endSellerIndex) {            threadID = threadNumber;            maxTrades = maxExchanges;            beginBuyers = 1;          //startBuyerIndex;            endBuyers = numberOfBuyers ; //endBuyerIndex;            beginSellers = 1;         //startSellerIndex;            endSellers = numberOfSellers;  //endSellerIndex;            //randomStream = new Random();        }        public void run() {            int buyerIndex, sellerIndex;            double bidPrice, askPrice, transactionPrice;            for (int counter = 1; counter <= maxTrades; counter++) {                //                // Pick a buyer at random who is still looking tu buy...                //                do {                    buyerIndex = beginBuyers + ThreadLocalRandom.current().nextInt(endBuyers - beginBuyers + 1) - 1;		    if(!people.buyers[buyerIndex].lock.tryAcquire()){			continue;		    }		    if(people.buyers[buyerIndex].hasTraded()){			people.buyers[buyerIndex].lock.release();			continue;		    } else {			break;		    }                } while (true);                bidPrice = people.buyers[buyerIndex].formBidPrice();                //                // Pick a seller at random who is still looking to sell...                //                do {                    sellerIndex = beginSellers + ThreadLocalRandom.current().nextInt(endSellers - beginSellers + 1) - 1;		    if(!people.sellers[sellerIndex].lock.tryAcquire()){			continue;		    }		    if(people.sellers[sellerIndex].hasTraded()){			people.sellers[sellerIndex].lock.release();			continue;		    } else {			break;		    }                } while (true);                askPrice = people.sellers[sellerIndex].formAskPrice();                if (bidPrice > askPrice) {                    transactionPrice = askPrice + ThreadLocalRandom.current().nextDouble(0, 1) * (bidPrice - askPrice);                    people.buyers[buyerIndex].setTraded(true);                    people.buyers[buyerIndex].price = transactionPrice;                    people.sellers[sellerIndex].setTraded(true);                    people.sellers[sellerIndex].price = transactionPrice;                    Transactions[threadID].AddDatuum(transactionPrice);                    if (verboseOutput) {                        System.out.print(threadID + "Found two agents willing to trade: ");                        System.out.println("Price of " + twoDigits.format(transactionPrice) +                                " with buyer's bid of " + twoDigits.format(bidPrice) + " and seller asking price of " + twoDigits.format(askPrice));                    }                } else if (verboseOutput) {                    System.out.println(threadID + "Could not trade: " + "; buyer's bid was " + twoDigits.format(bidPrice) +                            " while seller's asking price was " + twoDigits.format(askPrice));                }		people.buyers[buyerIndex].lock.release();		people.sellers[sellerIndex].lock.release();            }        }    }    public class DoTrades implements Runnable {        int threadID;        int maxTrades;        int beginBuyers;        int endBuyers;        int beginSellers;        int endSellers;        //Random randomStream;            public DoTrades(int threadNumber, int maxExchanges, int startBuyerIndex, int endBuyerIndex, int startSellerIndex, int endSellerIndex) {            threadID = threadNumber;            maxTrades = maxExchanges;            beginBuyers = startBuyerIndex;            endBuyers = endBuyerIndex;            beginSellers = startSellerIndex;            endSellers = endSellerIndex;            //randomStream = new Random();        }        public void run() {            int buyerIndex, sellerIndex;            double bidPrice, askPrice, transactionPrice;            for (int counter = 1; counter <= maxTrades; counter++) {                //                // Pick a buyer at random who is still looking tu buy...                //                do {                    buyerIndex = beginBuyers + ThreadLocalRandom.current().nextInt(endBuyers - beginBuyers + 1) - 1;		    //System.out.println("" + beginBuyers + " " + endBuyers );                } while (people.buyers[buyerIndex].hasTraded());                bidPrice = people.buyers[buyerIndex].formBidPrice();                //                // Pick a seller at random who is still looking to sell...                //                do {                    sellerIndex = beginSellers + ThreadLocalRandom.current().nextInt(endSellers - beginSellers + 1) - 1;                } while (people.sellers[sellerIndex].hasTraded());                askPrice = people.sellers[sellerIndex].formAskPrice();                if (bidPrice > askPrice) {                    transactionPrice = askPrice + ThreadLocalRandom.current().nextDouble(0, 1) * (bidPrice - askPrice);                    people.buyers[buyerIndex].setTraded(true);                    people.buyers[buyerIndex].price = transactionPrice;                    people.sellers[sellerIndex].setTraded(true);                    people.sellers[sellerIndex].price = transactionPrice;                    Transactions[threadID].AddDatuum(transactionPrice);                    if (verboseOutput) {                        System.out.print(threadID + "Found two agents willing to trade: ");                        System.out.println("Price of " + twoDigits.format(transactionPrice) +                                " with buyer's bid of " + twoDigits.format(bidPrice) + " and seller asking price of " + twoDigits.format(askPrice));                    }                } else if (verboseOutput) {                    System.out.println(threadID + "Could not trade: " + "; buyer's bid was " + twoDigits.format(bidPrice) +                            " while seller's asking price was " + twoDigits.format(askPrice));                }            }        }    }    private void OpenTrading() {        System.out.println("\n Zero-Intelligence traders, version " + version + ": Rob Axtell, George Mason University");        long startTime = Calendar.getInstance().getTimeInMillis();        if (!threadedTrades) {            DoSingleThreadedTrades();        } else {            DoMultiThreadedTrades();        }        long finishTime = Calendar.getInstance().getTimeInMillis();        for (int i = 1; i < numberOfThreads; i++) {            Transactions[0].CombineWithDifferentData(Transactions[i]);        }        System.out.println("\nFinal stats: " + Transactions[0].GetN() + " transactions at " +                twoDigits.format(Transactions[0].GetAverage()) + " average price; " +                twoDigits.format(Transactions[0].GetStdDev()) + " standard deviation.\n");        System.out.println("Elapsed time: " + (finishTime - startTime) + " milliseconds\n");    }    // Main entry point    //    public static void main(String[] args) {        ZITraders Market = new ZITraders();        //focus on old for now    	//Market.doNew = false;        numberOfBuyers = Integer.parseInt(args[0]);        numberOfSellers = Integer.parseInt(args[0]);        maxNumberOfTrades = Integer.parseInt(args[1]);        numberOfThreads = Integer.parseInt(args[2]);    	    	if(args[3].equals("old")) {    	    Market.doNew = false;    	}        Market.OpenTrading();    }}